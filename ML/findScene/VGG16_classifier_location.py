# -*- coding: utf-8 -*-
"""VGG16_classifier_location.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1slgyEDEiMTrqZiJIi689zoYCrapni4RQ
"""

import tensorflow as tf
import pandas as pd
import numpy as np
import numpy as np
import keras
import cv2
import os
import zipfile

from keras import utils as np_utils
from keras._tf_keras.keras.callbacks import EarlyStopping
from keras._tf_keras.keras.models import Sequential, load_model
from keras._tf_keras.keras.layers import Flatten, Dense, Dropout, RandomRotation
from keras._tf_keras.keras.applications import vgg16
from glob import glob
from PIL import Image
from sklearn.model_selection import train_test_split

image_dir = "ml/findScene/images"
dataset_dir = "ml/findScene/dataset"
dataset_path = 'ml/findScene/dataset/dataset.xlsx'
model_path = "ml/findScene/model.keras"

img_df = pd.read_excel(dataset_path)

"""**Загружаем изображения**"""

def loadPathsImages():
  names = img_df['Путь']
  paths = []

  for name in names:
    full_path = image_dir + "/" + str(name)
    paths.append(full_path)

  paths = np.asarray(paths)
  return paths

def loadImages(paths):
  images = []

  for path in paths:
    image = cv2.imread(path)
    array = np.array(image)
    images.append(array)

  return images

"""**Уменьшаем размер до 224x224 и нормализуем**"""

def resizeImages(images):
  reImages = []

  for img in images:
    new_img = cv2.resize(img, (224, 224))
    new_img = new_img / 255
    reImages.append(new_img)
  return reImages

"""**Классы изображений**"""

classes = {1:'Спальня', 2:'Частный дом', 3:'Промышленный район', 4:'Кухня', 5:'Гостинная', 6:'Море', 7:'Лес', 8:
 'Дорога', 9:'Здание', 10:'Гора',11:'Равнина', 12:'Улица', 13:'Небоскреб', 14:'Рабочий кабинет', 15:'Магазин'}

"""**Загружаем метки и кодириуем по OHE**"""

def loadLabels():
  df = pd.read_excel(dataset_path)

  labels_df = df['Метка класса']
  labels = []

  for label in labels_df:
    # Метки идут от 1, поэтому - 1
    labels.append(label - 1)

  labels = np.array(labels)
  label_cat = keras.utils.to_categorical(labels)

  return label_cat

"""**Подготавливаем модель**"""

def prepareModel():
  vgg_model = vgg16.VGG16(weights='imagenet', include_top=False, input_shape=(224,224,3))

  model = Sequential()
  model.add(RandomRotation(factor=0.2, fill_mode='reflect', interpolation='nearest'))
  model.add(vgg_model)
  model.add(Flatten())
  model.add(Dense(256, activation='relu'))
  model.add(Dropout(0.25))
  model.add(Dense(512, activation='relu'))
  model.add(Dense(15, activation='softmax'))

  # Разблокируем все последние слои для обучения
  vgg_model.trainable = True
  trainable = False
  for layer in vgg_model.layers:
      if layer.name == 'block5_conv1':
          trainable = True
      layer.trainable = trainable

  return model

"""**Компилируем и обучаем модель**"""

def trainModel():
  if os.path.exists(model_path):
    model = load_model(model_path)
    return model
  
  model = prepareModel()

  early_stop = EarlyStopping(monitor='accuracy', min_delta=0.0001, patience=2, verbose=1)
  model.compile(optimizer='Adam', loss='categorical_crossentropy', metrics=['accuracy'])

  model.fit(X_train, y_train, epochs=25, batch_size=256)
  model.save(model_path)

  return model

"""**Оцениваем модель**"""

def evaluateModel(model):
  results = model.evaluate(X_test, y_test, batch_size=64)
  print('test loss, test acc:', results)

"""**Прогноз модели**"""

def predict(url:str):
  model = trainModel()

  image = Image.open(url)
  image = np.array(image)
  image = cv2.resize(image, (224, 224))
  image = image / 255

  image = np.expand_dims(image, axis=0)
  pred = model.predict(image)
  return classes[np.argmax(pred) + 1]

paths = loadPathsImages()
images = loadImages(paths)

X = np.asarray(resizeImages(images))
y = loadLabels()

del paths
del images

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=True)

del X
del y


# predict('sky.jpg')